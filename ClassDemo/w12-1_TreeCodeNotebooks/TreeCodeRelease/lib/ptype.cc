// -*- buffer-read-only: t -*-

#ifndef __PTYPE_CC__
#define __PTYPE_CC__


/*
Structure types to go with the AOS class.
The complexity here is due to the fact that C++ does not have meaningful
reflection.

--------------------------------------------------------------------------------
DO NOT EDIT THIS FILE -- it is made by the mkAOStype Python script from the basic
structure in <filename>.in

If you want to change the structures in <filename>.cc, change <filename>.in
and run "./mkAOStype <filename>.in" again.
--------------------------------------------------------------------------------
*/

#include "typename.cc"
#include "smallvec.cc"

// forward declaration
template <typename T>
struct Ptype;

// PtypeRef<T> container allows using Ptype[i].a syntax to reference elements;
// it must match the Ptype<T> container precisely
template <typename T>
struct PtypeRef {

    void set( const Ptype<T> &Q );
    PtypeRef<T>& operator=(const PtypeRef<T> &);
    PtypeRef<T>& operator=(const Ptype<T> &);

    SmallVec<T,3> &r;
    SmallVec<T,3> &v;
    SmallVec<T,3> &a;
    T &pot;
    T &mass;
    int &id;
};

// PtypePtr<T> container allows using Ptype.arrays().a syntax to reference whole arrays;
// it must match the Ptype<T> container precisely
template <typename T>
struct PtypePtr {
    SmallVec<T,3> *r;
    SmallVec<T,3> *v;
    SmallVec<T,3> *a;
    T *pot;
    T *mass;
    int *id;
};

// The actual Ptype structure
template <typename T>
struct Ptype {
    Ptype( ) {}
    Ptype( SmallVec<T,3> r, SmallVec<T,3> v, SmallVec<T,3> a, T pot, T mass, int id ) : r(r), v(v), a(a), pot(pot), mass(mass), id(id) {}
    Ptype( PtypeRef<T> Q ) : r(Q.r), v(Q.v), a(Q.a), pot(Q.pot), mass(Q.mass), id(Q.id) {}

    SmallVec<T,3> r;
    SmallVec<T,3> v;
    SmallVec<T,3> a;
    T pot;
    T mass;
    int id;

    // basetype must be set to a tuple of pointers to all of the types in Ptype
    using basetype = std::tuple<SmallVec<T,3>*, SmallVec<T,3>*, SmallVec<T,3>*, T*, T*, int*>;
    using tuptype = std::tuple<SmallVec<T,3>, SmallVec<T,3>, SmallVec<T,3>, T, T, int>;
    using tupref = std::tuple<SmallVec<T,3>&, SmallVec<T,3>&, SmallVec<T,3>&, T&, T&, int&>;
    using reftype = PtypeRef<T>;
    using ptrtype = PtypePtr<T>;

    static constexpr std::array<const std::basic_string_view<char>, 12> defs =
            { type_name<decltype(r)>(), "r", type_name<decltype(v)>(), "v", type_name<decltype(a)>(), "a", type_name<decltype(pot)>(), "pot", type_name<decltype(mass)>(), "mass", type_name<decltype(id)>(), "id", };
};

template <typename T>
void PtypeRef<T>::set( const Ptype<T> &Q ) {
    r = Q.r;
    v = Q.v;
    a = Q.a;
    pot = Q.pot;
    mass = Q.mass;
    id = Q.id;
}

template <typename T>
PtypeRef<T>& PtypeRef<T>::operator=( const PtypeRef<T>& Q) {
    r = Q.r;
    v = Q.v;
    a = Q.a;
    pot = Q.pot;
    mass = Q.mass;
    id = Q.id;
    return *this;
}

template <typename T>
PtypeRef<T>& PtypeRef<T>::operator=( const Ptype<T>& Q) {
    r = Q.r;
    v = Q.v;
    a = Q.a;
    pot = Q.pot;
    mass = Q.mass;
    id = Q.id;
    return *this;
}

#endif // __PTYPE_CC__
